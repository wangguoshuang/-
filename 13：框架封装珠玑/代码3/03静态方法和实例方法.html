<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <script>
        /*
        * 实例成员：
        * 提供给实例使用的方法和属性，就称之为实例成员。
        *
        * 实例方法：
        * 提供给实例使用的方法，就称之为实例方法。
        *
        * 静态成员（类成员）：
        * 提供给函数使用的方法和属性，就称之为静态成员。
        *
        * 静态方法（类方法）：
        * 提供给函数使用的方法，就称之为静态方法。
        *
        * 类：
        * 在ES6之前，通常我们会把构造函数当做是类。
        * */

        //
        function Person( name, age, MAX_AGE ) {

            /*
            * 这里通过this添加的实例成员，
            * 都是添加到了实例自身上。
            * */

            // 这是实例成员，因为这是供实例使用的。
            this.name = name;

            // 这是实例成员，因为这是供实例使用的。
            this.age = age;

            // 这是实例成员，因为这是供实例使用的。
            // 实例成员的作用面比较窄，
            // 这里代表某个人最大的年龄
            this.MAX_AGE = MAX_AGE;
        }

        // 这是静态成员，因为这是添加给函数使用的。
        // 静态成员的作用面更广，代表的含义也更广。
        // 我们这里代表整个人类最大的年龄
        Person.MAX_AGE = 300;

        Person.prototype = {
            constructor: Person,

            // 这是实例成员，因为这是供实例使用的。
            // 但是这里的属性和方法，并没有添加到实例自身。
            run: function(  ) {

                // 为了减少冗余，复用静态方法
                Person.run( this.age );
            }
        }

        // 如果一些方法，通用性已经很强了，
        // 那么就可以考虑把他加到函数中作为静态方法使用。
        Person.run = function( age ) {
            if ( age < 5 ) {
                console.log( '趴着跑' );
            }else if ( age >= 5 && age <= 16 ) {
                console.log( '跳着跑' );
            }else if ( age > 16 && age < 30 ) {
                console.log( '跑酷' );
            }else {
                console.log( '拄着拐杖跑' );
            }
        }


        /*
        * 为什么都是实例方法复用静态方法：
        * 因为。静态方法服务的面更广，即可以服务实例，
        * 也可以服务其他的地方，所以实例方法可以复用静态方法( 即实例方法中可以使用静态方法解决问题 )。
        *
        * 而实例方法只服务于实例，没法服务与更多的地方，
        * 所以静态方法无法复用实例方法( 即静态方法中无法使用实例方法解决问题 )。
        *
        * */
    </script>
</body>
</html>